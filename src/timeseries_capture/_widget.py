# """
# This module contains four napari widgets declared in
# different ways:

# - a pure Python function flagged with `autogenerate: true`
#     in the plugin manifest. Type annotations are used by
#     magicgui to generate widgets for each parameter. Best
#     suited for simple processing tasks - usually taking
#     in and/or returning a layer.
# - a `magic_factory` decorated function. The `magic_factory`
#     decorator allows us to customize aspects of the resulting
#     GUI, including the widgets associated with each parameter.
#     Best used when you have a very simple processing task,
#     but want some control over the autogenerated widgets. If you
#     find yourself needing to define lots of nested functions to achieve
#     your functionality, maybe look at the `Container` widget!
# - a `magicgui.widgets.Container` subclass. This provides lots
#     of flexibility and customization options while still supporting
#     `magicgui` widgets and convenience methods for creating widgets
#     from type annotations. If you want to customize your widgets and
#     connect callbacks, this is the best widget option for you.
# - a `QWidget` subclass. This provides maximal flexibility but requires
#     full specification of widget layouts, callbacks, events, etc.

# References:
# - Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
# - magicgui docs: https://pyapp-kit.github.io/magicgui/

# Replace code below according to your needs.
# """

import math
import os
import time

import h5py
import numpy as np
import serial
from qtpy.QtWidgets import (
    QCheckBox,
    QFileDialog,
    QLabel,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QVBoxLayout,
    QWidget,
)


class NematostellaTimeSeriesCapture(QWidget):
    def __init__(self):
        super().__init__()

        layout = QVBoxLayout()

        # Button to start live preview
        self.live_preview_button = QPushButton("Start Live Preview")
        self.live_preview_button.clicked.connect(self.start_live_preview)
        layout.addWidget(self.live_preview_button)

        # Record button
        self.record_button = QPushButton("Start Recording")
        self.record_button.clicked.connect(self.start_recording)
        layout.addWidget(self.record_button)

        # Test button to simulate system behavior
        self.test_button = QPushButton("Run Test Simulation")
        self.test_button.clicked.connect(self.run_test_simulation)
        layout.addWidget(self.test_button)

        # Recording duration input (in minutes)
        self.duration_label = QLabel("Recording Duration (minutes):")
        self.duration_input = QLineEdit()
        layout.addWidget(self.duration_label)
        layout.addWidget(self.duration_input)

        # Interval between frames input (in seconds)
        self.interval_label = QLabel("Interval between frames (seconds):")
        self.interval_input = QLineEdit()
        layout.addWidget(self.interval_label)
        layout.addWidget(self.interval_input)

        # Checkbox for saving metadata
        self.save_metadata_checkbox = QCheckBox("Save Metadata")
        layout.addWidget(self.save_metadata_checkbox)

        # Directory selection button and label
        self.select_dir_button = QPushButton("Select Save Directory")
        self.select_dir_button.clicked.connect(self.select_directory)
        layout.addWidget(self.select_dir_button)

        self.selected_dir_label = QLabel("No directory selected")
        layout.addWidget(self.selected_dir_label)

        self.selected_directory = None  # To store the selected directory

        self.setLayout(layout)

        # Setup serial connection to ESP32
        try:
            self.serial_port = serial.Serial("/dev/ttyUSB0", 115200, timeout=1)
        except serial.SerialException as e:
            self.show_error_message(f"Failed to open serial port: {e}")
            self.serial_port = None

    def start_live_preview(self):
        # Dummy implementation, replace with actual code to start live camera feed
        print("Starting live preview...")

    def select_directory(self):
        """Open a dialog to select a directory for saving the HDF5 files."""
        directory = QFileDialog.getExistingDirectory(self, "Select Directory")
        if directory:
            self.selected_directory = directory
            self.selected_dir_label.setText(f"Selected Directory: {directory}")
        else:
            self.selected_dir_label.setText("No directory selected")

    def send_esp32_command(self, command):
        """Sends a command to the ESP32 over the serial port or simulates it."""
        if self.serial_port and self.serial_port.is_open:
            try:
                # Send the command to the ESP32 via the serial port
                self.serial_port.write(f"{command}\n".encode())
                print(f"Sent command to ESP32: {command}")
            except (
                serial.SerialException
            ) as e:  # More specific exception handling
                # Handle serial communication errors
                self.show_error_message(f"Error communicating with ESP32: {e}")
        else:
            # Simulate ESP32 command in the test environment
            print(f"Simulating ESP32 command: {command}")

    def calculate_frame_size(self, resolution, bit_depth, color_channels):
        """Calculate the size of a single frame in MB."""
        width, height = resolution
        frame_size = (width * height * bit_depth * color_channels) / (
            8 * 3072 * 2048
        )  # Convert to MB
        return frame_size

    def calculate_total_data_size(self, frame_size, total_duration, interval):
        """Calculate the total data size for the given duration and interval."""
        num_frames = total_duration / interval
        total_size = frame_size * num_frames  # Total size in MB
        return total_size, num_frames

    def create_hdf5_file(self, file_name, frame_data):
        """Create and save frame data to an HDF5 file."""
        with h5py.File(file_name, "w") as f:
            f.create_dataset("frames", data=frame_data)

    def split_and_save_frames(
        self, frames, frame_size, memory_limit_mb, save_dir
    ):
        """Split frames into multiple HDF5 files if they exceed memory limits."""
        max_frames_per_file = memory_limit_mb / frame_size
        num_files = math.ceil(
            len(frames) / max_frames_per_file
        )  # Ensure num_files is an integer
        for i in range(num_files):
            start_idx = int(i * max_frames_per_file)
            end_idx = int((i + 1) * max_frames_per_file)
            file_name = os.path.join(save_dir, f"frames_{i+1}.hdf5")
            self.create_hdf5_file(file_name, frames[start_idx:end_idx])
            print(
                f"Saved {file_name} with {len(frames[start_idx:end_idx])} frames"
            )

    def start_recording(self):
        """Starts the recording process, synchronizing LED and frame capturing."""
        self.record_button.setEnabled(False)

        try:
            # Convert duration from minutes to seconds
            duration = float(self.duration_input.text()) * 60
            interval = float(self.interval_input.text())
            memory_limit_mb = 5000  # Example memory limit for splitting files

            if duration <= 0 or interval <= 0:
                raise ValueError("All input values must be greater than zero.")
        except ValueError:
            self.show_error_message(
                "Invalid input values! Ensure all inputs are valid positive numbers."
            )
            self.record_button.setEnabled(True)
            return

        # Check if a directory is selected
        if not self.selected_directory:
            self.show_error_message(
                "Please select a directory to save the files."
            )
            self.record_button.setEnabled(True)
            return

        # Frame configuration (dummy values for example)
        resolution = (3072, 2048)  # Example resolution (Width x Height)
        bit_depth = 16  # Example bit depth
        color_channels = 3  # Example color channels (1 for grayscale)

        # Calculate frame size and total data size
        frame_size = self.calculate_frame_size(
            resolution, bit_depth, color_channels
        )
        total_data_size, num_frames = self.calculate_total_data_size(
            frame_size, duration, interval
        )

        print(
            f"Total Data Size: {total_data_size:.2f} MB, Number of Frames: {int(num_frames)}"
        )

        # Check if we need to split the data into multiple HDF5 files
        save_dir = self.selected_directory
        os.makedirs(save_dir, exist_ok=True)

        # Simulate capturing frames (replace with actual frame data)
        frames = [
            np.zeros((resolution[0], resolution[1]), dtype=np.uint16)
        ] * int(
            num_frames
        )  # Placeholder image frames

        # Split and save frames into HDF5 files if needed
        self.split_and_save_frames(
            frames, frame_size, memory_limit_mb, save_dir
        )

        self.record_button.setEnabled(True)

    def run_test_simulation(self):
        """Simulates the recording process and tests ESP32-related errors."""
        self.test_button.setEnabled(False)

        try:
            # Convert duration from minutes to seconds for testing
            duration = float(self.duration_input.text()) * 60
            interval = float(self.interval_input.text())
            memory_limit_mb = 5000  # Example memory limit for splitting files

            if duration <= 0 or interval <= 0:
                raise ValueError("All input values must be greater than zero.")
        except ValueError:
            self.show_error_message(
                "Invalid input values! Ensure all inputs are valid positive numbers."
            )
            self.test_button.setEnabled(True)
            return

        # Frame configuration (dummy values for example)
        resolution = (3072, 2048)  # Example resolution (Width x Height)
        bit_depth = 16  # Example bit depth
        color_channels = 3  # Example color channels (1 for grayscale)

        # Calculate frame size and total data size
        frame_size = self.calculate_frame_size(
            resolution, bit_depth, color_channels
        )
        total_data_size, num_frames = self.calculate_total_data_size(
            frame_size, duration, interval
        )

        print(
            f"Test Simulation - Total Data Size: {total_data_size:.2f} MB, Number of Frames: {int(num_frames)}"
        )

        # Simulate capturing frames (replace with actual frame data)
        frames = [
            np.zeros((resolution[0], resolution[1]), dtype=np.uint16)
        ] * int(
            num_frames
        )  # Placeholder image frames

        # Split and save frames into HDF5 files if needed
        save_dir = (
            self.selected_directory
            if self.selected_directory
            else "./test_data"
        )
        os.makedirs(save_dir, exist_ok=True)
        self.split_and_save_frames(
            frames, frame_size, memory_limit_mb, save_dir
        )

        self.test_button.setEnabled(True)

    def simulate_esp32_response(self, command):
        """Simulates the ESP32 responses to the given command."""
        command = command.upper()

        if command == "ON":
            print("Simulated ESP32 Response: Turning LED ON")
        elif command == "OFF":
            print("Simulated ESP32 Response: Turning LED OFF")
        elif command.startswith("ON FOR"):
            try:
                on_time = int(command.split()[-1])
                if on_time > 0:
                    print(
                        f"Simulated ESP32 Response: Turning LED ON for {on_time} seconds"
                    )
                    time.sleep(on_time)
                    print("Simulated ESP32 Response: LED OFF after timed ON")
                else:
                    print(
                        "Simulated ESP32 Error: Invalid time for 'ON FOR' command."
                    )
            except ValueError:
                print(
                    "Simulated ESP32 Error: Invalid time format in 'ON FOR' command."
                )
        else:
            print(
                f"Simulated ESP32 Error: Unknown command '{command}' received."
            )

    def close_serial(self):
        """Close the serial port when done."""
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()

    def show_error_message(self, message):
        """Display error messages to the user."""
        error_msg = QMessageBox(self)
        error_msg.setIcon(QMessageBox.Critical)
        error_msg.setWindowTitle("Error")
        error_msg.setText(message)
        error_msg.exec_()
